/**
 * HeyGenPuppet Component
 *
 * This component converts the HeyGen avatar into a "puppet" that only handles visual presentation.
 * It removes all conversation logic and user input handling, serving purely as a visual display
 * for text responses generated by ElevenLabs Conversational AI.
 *
 * Puppet Mode:
 * - NO user input handling
 * - NO conversation logic
 * - NO knowledge base queries
 * - ONLY visual rendering and text-to-speech
 * - ONLY responds to external speak() commands
 */

"use client";

import React, { useCallback, useEffect, useRef, useState } from "react";
import {
  AvatarQuality,
  StreamingEvents,
  VoiceChatTransport,
  VoiceEmotion,
  StartAvatarRequest,
  STTProvider,
  ElevenLabsModel,
  TaskType,
} from "@heygen/streaming-avatar";
import { useMemoizedFn, useUnmount } from "ahooks";

import { useStreamingAvatarSession } from "./logic/useStreamingAvatarSession";
import { StreamingAvatarProvider, StreamingAvatarSessionState } from "./logic";
import { ChromaKeyAvatar } from "./ChromaKeyAvatar";

import { ENV_IDS } from "@/app/lib/constants";

// Puppet configuration - no knowledge base, no conversation logic
const PUPPET_CONFIG: StartAvatarRequest = {
  quality: AvatarQuality.High,
  avatarName: ENV_IDS.AVATAR_ID,
  // NO knowledgeId - puppet doesn't handle conversation
  voice: {
    voiceId: ENV_IDS.VOICE_ID,
    rate: 1.1,
    emotion: VoiceEmotion.EXCITED,
    model: ElevenLabsModel.eleven_flash_v2_5,
  },
  language: "es",
  voiceChatTransport: VoiceChatTransport.WEBSOCKET,
  sttSettings: {
    provider: STTProvider.DEEPGRAM,
  },
};

export interface HeyGenPuppetProps {
  onReady?: () => void;
  onSpeakingStart?: () => void;
  onSpeakingEnd?: () => void;
  onError?: (error: Error) => void;
  className?: string;
}

function HeyGenPuppetComponent({
  onReady,
  onSpeakingStart,
  onSpeakingEnd,
  onError,
  className = "",
}: HeyGenPuppetProps) {
  const {
    initAvatar,
    startAvatar,
    stopAvatar,
    sessionState,
    stream,
    avatarRef,
  } = useStreamingAvatarSession();

  const [isLoading, setIsLoading] = useState(false);
  const [isSpeaking, setIsSpeaking] = useState(false);
  const mediaStream = useRef<HTMLVideoElement>(null);

  /**
   * Fetch HeyGen access token
   */
  async function fetchAccessToken() {
    try {
      const response = await fetch("/api/get-access-token", {
        method: "POST",
      });
      const token = await response.text();

      return token;
    } catch (error) {
      console.error("Error fetching HeyGen access token:", error);
      throw error;
    }
  }

  /**
   * Initialize the HeyGen avatar in puppet mode
   */
  const initializePuppet = useMemoizedFn(async () => {
    try {
      // Check if already connected
      if (sessionState !== StreamingAvatarSessionState.INACTIVE) {
        return;
      }

      setIsLoading(true);

      // ALWAYS get a fresh token for each new session
      console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_FETCHING_NEW_TOKEN`);
      const token = await fetchAccessToken();

      console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_TOKEN_OBTAINED`);

      // Always reinitialize avatar with fresh token for new session
      console.log(
        `⏱️ [${new Date().toISOString()}] HEYGEN_INITIALIZING_AVATAR`,
      );
      initAvatar(token);

      // Setup puppet-specific event handlers (no user input events)
      if (avatarRef.current) {
        avatarRef.current.on(StreamingEvents.AVATAR_START_TALKING, () => {
          console.log(
            `⏱️ [${new Date().toISOString()}] HEYGEN_AVATAR_START_TALKING`,
          );
          setIsSpeaking(true);
          onSpeakingStart?.();
        });

        avatarRef.current.on(StreamingEvents.AVATAR_STOP_TALKING, () => {
          console.log(
            `⏱️ [${new Date().toISOString()}] HEYGEN_AVATAR_STOP_TALKING`,
          );
          setIsSpeaking(false);
          onSpeakingEnd?.();
        });

        avatarRef.current.on(StreamingEvents.STREAM_DISCONNECTED, () => {
          setIsLoading(false);
        });

        avatarRef.current.on(StreamingEvents.STREAM_READY, async (_event) => {
          setIsLoading(false);
          onReady?.();
        });
      }

      // Start avatar with puppet configuration (no knowledge base)
      await startAvatar(PUPPET_CONFIG);
    } catch (error) {
      console.error("❌ Error initializing HeyGen puppet:", error);
      setIsLoading(false);
      onError?.(error as Error);
    }
  });

  /**
   * Make the puppet speak given text (called by ElevenLabs conversation manager)
   */
  const speak = useCallback(
    async (text: string): Promise<void> => {
      const speakStartTime = performance.now();

      console.log(
        `⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_CALLED: "${text}"`,
      );

      if (sessionState !== StreamingAvatarSessionState.CONNECTED) {
        console.log(
          `⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_REJECTED: Session not connected (${sessionState})`,
        );

        return;
      }

      try {
        if (!avatarRef.current) {
          console.log(
            `⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_REJECTED: Avatar ref not available`,
          );

          return;
        }

        console.log(
          `⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_STARTING: Calling avatarRef.current.speak()`,
        );

        // Use REPEAT task type so puppet just says what it's told (no AI processing)
        await avatarRef.current.speak({
          text: text,
          task_type: TaskType.REPEAT,
        });

        const speakEndTime = performance.now();
        const speakDuration = speakEndTime - speakStartTime;

        console.log(
          `⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_COMPLETED: Duration: ${speakDuration.toFixed(2)}ms`,
        );
      } catch (error: any) {
        const speakEndTime = performance.now();
        const speakDuration = speakEndTime - speakStartTime;

        // Check if it's a 401 error (token expired)
        if (error?.message?.includes("401") || error?.status === 401) {
          console.error(
            `⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_ERROR_401: Token expired - Duration: ${speakDuration.toFixed(2)}ms`,
          );
          console.error(
            `❌ HeyGen token expired. Need to restart session with fresh token.`,
          );
        } else {
          console.error(
            `⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_ERROR: Duration: ${speakDuration.toFixed(2)}ms`,
            error,
          );
        }

        onError?.(error as Error);
      }
    },
    [sessionState, onError, avatarRef],
  );

  /**
   * Interrupt the puppet's current speech (called when ElevenLabs detects interruption)
   */
  const interrupt = useCallback(async (): Promise<void> => {
    if (sessionState !== StreamingAvatarSessionState.CONNECTED) {
      return;
    }

    try {
      if (!avatarRef.current) {
        return;
      }

      // Interrupt current speaking task
      await avatarRef.current.interrupt();
    } catch (error: any) {
      console.error("❌ Error interrupting puppet:", error);
      onError?.(error as Error);
    }
  }, [sessionState, onError, avatarRef]);

  /**
   * Stop the puppet
   */
  const stopPuppet = useMemoizedFn(async () => {
    try {
      console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_STOPPING_PUPPET`);
      await stopAvatar();

      // Clear avatar ref to force fresh initialization next time
      if (avatarRef.current) {
        avatarRef.current = null;
      }

      console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_PUPPET_STOPPED`);
    } catch (error) {
      console.error("❌ Error stopping puppet:", error);
    }
  });

  /**
   * Cleanup on unmount
   */
  useUnmount(() => {
    stopAvatar();
  });

  /**
   * Handle stream ready for video display
   */
  const handleStreamReady = useMemoizedFn((_stream: MediaStream) => {
    // Stream ready
  });

  const handleStreamDisconnected = useMemoizedFn(() => {
    // Stream disconnected
  });

  // Session state changes
  useEffect(() => {
    if (sessionState === StreamingAvatarSessionState.CONNECTED) {
      onReady?.();
    }
  }, [sessionState, onReady]);

  // Expose puppet controls via ref or global
  useEffect(() => {
    if (typeof window !== "undefined") {
      (window as any).heygenPuppet = {
        speak,
        interrupt,
        initialize: initializePuppet,
        isReady: sessionState === StreamingAvatarSessionState.CONNECTED,
        isSpeaking,
        stop: stopPuppet,
      };
    }
  }, [
    speak,
    interrupt,
    sessionState,
    isSpeaking,
    stopPuppet,
    initializePuppet,
  ]);

  // Suppress WebRTC errors from HeyGen
  useEffect(() => {
    const originalConsoleError = console.error;

    console.error = (...args) => {
      const message = args[0];

      if (
        typeof message === "string" &&
        (message.includes("Unknown DataChannel error on lossy") ||
          message.includes("Unknown DataChannel error on reliable") ||
          message.includes("RTCErrorEvent"))
      ) {
        return; // Suppress these specific errors
      }
      originalConsoleError.apply(console, args);
    };

    return () => {
      console.error = originalConsoleError;
    };
  }, []);

  return (
    <div
      className={`relative w-full h-full flex items-center justify-center ${className}`}
    >
      {/* Avatar Video Display */}
      {sessionState !== StreamingAvatarSessionState.INACTIVE ? (
        <ChromaKeyAvatar
          ref={mediaStream}
          className="w-full h-full object-cover"
          sessionState={sessionState}
          stream={stream}
          onStreamDisconnected={handleStreamDisconnected}
          onStreamReady={handleStreamReady}
        />
      ) : (
        <div className="w-full h-full flex items-center justify-center">
          <img
            alt="Avatar Preview"
            className="w-full h-full object-contain"
            src="/JUJO.png"
          />
        </div>
      )}
    </div>
  );
}

/**
 * HeyGen Puppet with Provider
 */
export function HeyGenPuppet(props: HeyGenPuppetProps) {
  return (
    <StreamingAvatarProvider basePath={process.env.NEXT_PUBLIC_BASE_API_URL}>
      <HeyGenPuppetComponent {...props} />
    </StreamingAvatarProvider>
  );
}
