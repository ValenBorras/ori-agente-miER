/**
 * HeyGenPuppet Component
 * 
 * This component converts the HeyGen avatar into a "puppet" that only handles visual presentation.
 * It removes all conversation logic and user input handling, serving purely as a visual display
 * for text responses generated by ElevenLabs Conversational AI.
 * 
 * Puppet Mode:
 * - NO user input handling
 * - NO conversation logic
 * - NO knowledge base queries
 * - ONLY visual rendering and text-to-speech
 * - ONLY responds to external speak() commands
 */

"use client";

import React, { useCallback, useEffect, useRef, useState } from "react";
import {
  AvatarQuality,
  StreamingEvents,
  VoiceChatTransport,
  VoiceEmotion,
  StartAvatarRequest,
  STTProvider,
  ElevenLabsModel,
  TaskType,
} from "@heygen/streaming-avatar";
import { useMemoizedFn, useUnmount } from "ahooks";

import { useStreamingAvatarSession } from "./logic/useStreamingAvatarSession";
import { StreamingAvatarProvider, StreamingAvatarSessionState } from "./logic";
import { ChromaKeyAvatar } from "./ChromaKeyAvatar";
import { LoadingIcon } from "./Icons";

import { ENV_IDS } from "@/app/lib/constants";

// Puppet configuration - no knowledge base, no conversation logic
const PUPPET_CONFIG: StartAvatarRequest = {
  quality: AvatarQuality.High,
  avatarName: ENV_IDS.AVATAR_ID,
  // NO knowledgeId - puppet doesn't handle conversation
  voice: {
    voiceId: ENV_IDS.VOICE_ID,
    rate: 1.10,
    emotion: VoiceEmotion.EXCITED,
    model: ElevenLabsModel.eleven_flash_v2_5,
  },
  language: "es",
  voiceChatTransport: VoiceChatTransport.WEBSOCKET,
  sttSettings: {
    provider: STTProvider.DEEPGRAM,
  },
};

export interface HeyGenPuppetProps {
  onReady?: () => void;
  onSpeakingStart?: () => void;
  onSpeakingEnd?: () => void;
  onError?: (error: Error) => void;
  className?: string;
}

function HeyGenPuppetComponent({
  onReady,
  onSpeakingStart,
  onSpeakingEnd,
  onError,
  className = ""
}: HeyGenPuppetProps) {
  const { initAvatar, startAvatar, stopAvatar, sessionState, stream, avatarRef } =
    useStreamingAvatarSession();

  const [isLoading, setIsLoading] = useState(false);
  const [isSpeaking, setIsSpeaking] = useState(false);
  const mediaStream = useRef<HTMLVideoElement>(null);

  /**
   * Fetch HeyGen access token
   */
  async function fetchAccessToken() {
    try {
      const response = await fetch("/api/get-access-token", {
        method: "POST",
      });
      const token = await response.text();
      return token;
    } catch (error) {
      console.error("Error fetching HeyGen access token:", error);
      throw error;
    }
  }

  /**
   * Initialize the HeyGen avatar in puppet mode
   */
  const initializePuppet = useMemoizedFn(async () => {
    try {
      // Check if already connected
      if (sessionState !== StreamingAvatarSessionState.INACTIVE) {
        return;
      }

      setIsLoading(true);
      
      // ALWAYS get a fresh token for each new session
      console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_FETCHING_NEW_TOKEN`);
      const token = await fetchAccessToken();
      console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_TOKEN_OBTAINED`);
      
      // Always reinitialize avatar with fresh token for new session
      console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_INITIALIZING_AVATAR`);
      initAvatar(token);

      // Setup puppet-specific event handlers (no user input events)
      if (avatarRef.current) {
        avatarRef.current.on(StreamingEvents.AVATAR_START_TALKING, () => {
          console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_AVATAR_START_TALKING`);
          setIsSpeaking(true);
          onSpeakingStart?.();
        });

        avatarRef.current.on(StreamingEvents.AVATAR_STOP_TALKING, () => {
          console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_AVATAR_STOP_TALKING`);
          setIsSpeaking(false);
          onSpeakingEnd?.();
        });

        avatarRef.current.on(StreamingEvents.STREAM_DISCONNECTED, () => {
          setIsLoading(false);
        });

        avatarRef.current.on(StreamingEvents.STREAM_READY, async (event) => {
          setIsLoading(false);
          onReady?.();
        });
      }

      // Start avatar with puppet configuration (no knowledge base)
      await startAvatar(PUPPET_CONFIG);

    } catch (error) {
      console.error("❌ Error initializing HeyGen puppet:", error);
      setIsLoading(false);
      onError?.(error as Error);
    }
  });

  /**
   * Make the puppet speak given text (called by ElevenLabs conversation manager)
   */
  const speak = useCallback(async (text: string): Promise<void> => {
    const speakStartTime = performance.now();
    console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_CALLED: "${text}"`);
    
    if (sessionState !== StreamingAvatarSessionState.CONNECTED) {
      console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_REJECTED: Session not connected (${sessionState})`);
      return;
    }

    try {
      if (!avatarRef.current) {
        console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_REJECTED: Avatar ref not available`);
        return;
      }
      
      console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_STARTING: Calling avatarRef.current.speak()`);
      
      // Use REPEAT task type so puppet just says what it's told (no AI processing)
      await avatarRef.current.speak({
        text: text,
        task_type: TaskType.REPEAT,
      });
      
      const speakEndTime = performance.now();
      const speakDuration = speakEndTime - speakStartTime;
      console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_COMPLETED: Duration: ${speakDuration.toFixed(2)}ms`);
      
    } catch (error: any) {
      const speakEndTime = performance.now();
      const speakDuration = speakEndTime - speakStartTime;
      
      // Check if it's a 401 error (token expired)
      if (error?.message?.includes('401') || error?.status === 401) {
        console.error(`⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_ERROR_401: Token expired - Duration: ${speakDuration.toFixed(2)}ms`);
        console.error(`❌ HeyGen token expired. Need to restart session with fresh token.`);
      } else {
        console.error(`⏱️ [${new Date().toISOString()}] HEYGEN_SPEAK_ERROR: Duration: ${speakDuration.toFixed(2)}ms`, error);
      }
      
      onError?.(error as Error);
    }
  }, [sessionState, onError, avatarRef]);

  /**
   * Interrupt the puppet's current speech (called when ElevenLabs detects interruption)
   */
  const interrupt = useCallback(async (): Promise<void> => {
    if (sessionState !== StreamingAvatarSessionState.CONNECTED) {
      return;
    }

    try {
      if (!avatarRef.current) {
        return;
      }
      
      // Interrupt current speaking task
      await avatarRef.current.interrupt();
      
    } catch (error: any) {
      console.error("❌ Error interrupting puppet:", error);
      onError?.(error as Error);
    }
  }, [sessionState, onError, avatarRef]);

  /**
   * Stop the puppet
   */
  const stopPuppet = useMemoizedFn(async () => {
    try {
      console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_STOPPING_PUPPET`);
      await stopAvatar();
      
      // Clear avatar ref to force fresh initialization next time
      if (avatarRef.current) {
        avatarRef.current = null;
      }
      
      console.log(`⏱️ [${new Date().toISOString()}] HEYGEN_PUPPET_STOPPED`);
    } catch (error) {
      console.error("❌ Error stopping puppet:", error);
    }
  });

  /**
   * Cleanup on unmount
   */
  useUnmount(() => {
    stopAvatar();
  });

  /**
   * Handle stream ready for video display
   */
  const handleStreamReady = useMemoizedFn((stream: MediaStream) => {
    // Stream ready
  });

  const handleStreamDisconnected = useMemoizedFn(() => {
    // Stream disconnected
  });

  // Session state changes
  useEffect(() => {
    if (sessionState === StreamingAvatarSessionState.CONNECTED) {
      onReady?.();
    }
  }, [sessionState, onReady]);

  // Expose puppet controls via ref or global
  useEffect(() => {
    if (typeof window !== 'undefined') {
      (window as any).heygenPuppet = {
        speak,
        interrupt,
        initialize: initializePuppet,
        isReady: sessionState === StreamingAvatarSessionState.CONNECTED,
        isSpeaking,
        stop: stopPuppet
      };
    }
  }, [speak, interrupt, sessionState, isSpeaking, stopPuppet, initializePuppet]);

  // Suppress WebRTC errors from HeyGen
  useEffect(() => {
    const originalConsoleError = console.error;
    console.error = (...args) => {
      const message = args[0];
      if (typeof message === 'string' && (
        message.includes('Unknown DataChannel error on lossy') ||
        message.includes('Unknown DataChannel error on reliable') ||
        message.includes('RTCErrorEvent')
      )) {
        return; // Suppress these specific errors
      }
      originalConsoleError.apply(console, args);
    };

    return () => {
      console.error = originalConsoleError;
    };
  }, []);

  return (
    <div className={`relative w-full h-full flex items-center justify-center ${className}`}>
      {/* Avatar Video Display */}
      {sessionState !== StreamingAvatarSessionState.INACTIVE ? (
        <ChromaKeyAvatar
          ref={mediaStream}
          sessionState={sessionState}
          stream={stream}
          onStreamReady={handleStreamReady}
          onStreamDisconnected={handleStreamDisconnected}
          className="w-full h-full object-cover"
        />
      ) : (
        <div className="w-full h-full flex items-center justify-center">
          <img
            alt="Avatar Preview"
            className="w-full h-full object-contain"
            src="/JUJO.png"
          />
        </div>
      )}

      {/* Loading Overlay */}
      {isLoading && (
        <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center">
          <div className="flex items-center gap-3 text-white">
            <LoadingIcon />
            <span>Initializing puppet...</span>
          </div>
        </div>
      )}

      {/* Speaking Indicator */}
      {isSpeaking && (
        <div className="absolute bottom-4 left-4 bg-green-500 text-white px-3 py-1 rounded-full text-sm">
          Speaking...
        </div>
      )}
    </div>
  );
}

/**
 * HeyGen Puppet with Provider
 */
export function HeyGenPuppet(props: HeyGenPuppetProps) {
  return (
    <StreamingAvatarProvider basePath={process.env.NEXT_PUBLIC_BASE_API_URL}>
      <HeyGenPuppetComponent {...props} />
    </StreamingAvatarProvider>
  );
} 